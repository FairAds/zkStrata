package zkstrata.codegen;

import org.apache.commons.text.StringSubstitutor;
import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;
import zkstrata.domain.Proposition;
import zkstrata.domain.data.types.wrapper.InstanceVariable;
import zkstrata.domain.data.types.wrapper.Variable;
import zkstrata.domain.data.types.wrapper.WitnessVariable;
import zkstrata.exceptions.InternalCompilerException;

import java.io.*;
import java.util.*;
import java.util.stream.Collectors;

public class CodeGenerator {
    private static final Logger LOGGER = LogManager.getRootLogger();
    private static final String GADGETS_FILE_EXT = ".gadgets";
    private static final String INSTANCE_FILE_EXT = ".inst";
    private static final String WITNESS_FILE_EXT = ".wtns";

    private final String gadgetsFileName;
    private final String instanceFileName;
    private final String witnessFileName;

    private Map<InstanceVariable, String> instanceVariables = new HashMap<>();
    private Map<WitnessVariable, String> witnessVariables = new HashMap<>();

    public CodeGenerator(String name) {
        gadgetsFileName = name + GADGETS_FILE_EXT;
        instanceFileName = name + INSTANCE_FILE_EXT;
        witnessFileName = name + WITNESS_FILE_EXT;
    }

    public void generateProverTarget(Proposition proposition) {
        LOGGER.debug("Starting prover target code generation");

        generateGadgetsFile(proposition);
        generateInstanceFile(instanceVariables);
        generateWitnessFile(witnessVariables);
    }

    public void generateVerifierTarget(Proposition proposition) {
        LOGGER.debug("Starting verifier target code generation");

        generateGadgetsFile(proposition);
        generateInstanceFile(instanceVariables);
    }

    /**
     * Writes the target format generated by calling {@link Proposition#toTargetFormat()} on the given
     * {@code proposition} to a .gadgets file.
     *
     * @param proposition {@link Proposition} to generate the target format for
     */
    private void generateGadgetsFile(Proposition proposition) {
        try (BufferedWriter writer = new BufferedWriter(new FileWriter(gadgetsFileName))) {
            LOGGER.debug("Writing gadgets to {}", gadgetsFileName);

            List<TargetFormat> target = proposition.toTargetFormat();

            for (TargetFormat targetFormat : target) {
                Map<String, String> args = process(targetFormat.getArgs());
                StringSubstitutor substitutor = new StringSubstitutor(args, "%(", ")");
                String line = substitutor.replace(targetFormat.getFormat());
                writer.write(line);
                writer.newLine();

                LOGGER.debug("Generated gadget: {}", line);
            }
        } catch (IOException e) {
            throw new InternalCompilerException("Error while writing gadgets to {}.", gadgetsFileName);
        }
    }

    /**
     * Replaces the variables in the given map by their label in the target format.
     *
     * @param args {@link Map} of key to variables
     * @return {@link Map} of key to label
     */
    private Map<String, String> process(Map<String, Variable> args) {
        return args.entrySet()
                .stream()
                .collect(Collectors.toMap(Map.Entry::getKey, entry -> getLabel(entry.getValue())));
    }

    /**
     * Returns the label of the given {@link Variable}. The label consists of a type identifier (witness/instance) and
     * an index, which is determined by the variables occurrence in the target format.
     *
     * @param var {@link Variable} variable to get an index for
     * @return label for the given variable
     */
    private String getLabel(Variable var) {
        if (var instanceof WitnessVariable) {
            witnessVariables.putIfAbsent((WitnessVariable) var, String.format("W%d", witnessVariables.size()));
            return witnessVariables.get(var);
        }

        if (var instanceof InstanceVariable) {
            instanceVariables.putIfAbsent((InstanceVariable) var, String.format("I%d", instanceVariables.size()));
            return instanceVariables.get(var);
        }

        throw new InternalCompilerException("Invalid Variable instance: %s.", var.getClass());
    }

    /**
     * Serializes all {@link InstanceVariable} that occurred in the target format into a .inst file.
     * Requires that {@link CodeGenerator#generateGadgetsFile(Proposition)} has been called before.
     *
     * @param variables {@link Map} of instance variables to their label
     */
    private void generateInstanceFile(Map<InstanceVariable, String> variables) {
        try (BufferedWriter writer = new BufferedWriter(new FileWriter(instanceFileName))) {
            LOGGER.debug("Writing instance data to {}", instanceFileName);

            for (Map.Entry<InstanceVariable, String> entry : variables.entrySet()) {
                String line = String.format("%s = 0x%s", entry.getValue(), entry.getKey().getValue().toHex());
                writer.write(line);
                writer.newLine();
                LOGGER.debug("Generated instance data: {}", line);
            }
        } catch (IOException e) {
            throw new InternalCompilerException(e, "Error while writing instance data to {}.", instanceFileName);
        }
    }

    /**
     * Serializes all {@link WitnessVariable} that occurred in the target format into a .wtns file.
     * Requires that {@link CodeGenerator#generateGadgetsFile(Proposition)} has been called before.
     *
     * @param variables {@link Map} of witness variables to their label
     */
    private void generateWitnessFile(Map<WitnessVariable, String> variables) {
        try (BufferedWriter writer = new BufferedWriter(new FileWriter(witnessFileName))) {
            LOGGER.debug("Writing witness data to {}", witnessFileName);

            for (Map.Entry<WitnessVariable, String> entry : variables.entrySet()) {
                String line = String.format("%s = 0x%s", entry.getValue(), entry.getKey().getValue().toHex());
                writer.write(line);
                writer.newLine();
                LOGGER.debug("Generated witness data: {}", line);
            }
        } catch (IOException e) {
            throw new InternalCompilerException(e, "Error while writing witness data to {}.", witnessFileName);
        }
    }
}
